<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Handling conflicts</title>
        <link rel="stylesheet" href="6. Handling conflicts.css">
    </head>
    <body>
        <h1>Handling conflicts</h1>
        <h2>Conflicts rules</h2>
        <p>
            Stylesheets cascade. At a very simple level, this means that the origin and the order of 
            CSS rules matter. When two rules both have equal specificity, the one that is defined last 
            in the stylesheet is the one that will be used.
        </p>
        <h4>Example cascade</h4>
        <h2>Specificity</h2>
        <p>
            Specificity is an algorithm that the browser uses to decide which property value is applied 
            to an element.
        </p>
        <p>Specificity is basically a measure of how specific a selector's selection will be:</p>
        <ul>
            <li>
                <p>
                    A type (element) selector is less specific;  it will select all elements of that 
                    type that appear on a page, so it has less weight. 
                </p>
            </li>
            <li>
                <p>
                    A type (element) selector is less specific; it will select only the elements on a 
                    page that have a specific class attribute value, so it has more weight.
                </p>
            </li>
            <li>
                <p>
                    An ID selector is even more specific; it only selects a single element with a 
                    specific id value. It therefore has even more weight.
                </p>
            </li>
        </ul>
        <h2>Inheritance</h2>
        <p>
            Inheritance also needs to be understood in this context — some CSS property values set 
            on parent elements are inherited by their child elements, and some aren't.
        </p>
        <h2>Understanding inheritance</h2>
        <ul class="main">
            <li>Item One</li>
            <li>
                Item Two
                <ul>
                    <li>2.1</li>
                    <li>2.2</li>
                </ul>
            </li>
            <li>
                Item Three
                <ul class="special">
                    <li>
                        3.1
                        <ul>
                            <li>3.1.1</li>
                            <li>3.1.2</li>
                        </ul>
                    </li>
                    <li>3.2</li>
                </ul>
            </li>
        </ul>
        <p>
            Properties like <code>width</code> (as mentioned earlier), <code>margin</code>, <code>padding</code>, 
            and <code>border</code> are not inherited properties. If a border were to be inherited by 
            the children in this list example, every single list and list item would gain a 
            border — robably not an effect we would ever want!
        </p>
        <h3>Controlling inheritance</h3>
        <p>
            CSS provides five special universal property values for controlling inheritance. Every CSS 
            property accepts these values.
        </p>
        <code>inherit</code>
        <p>
            Sets the property value applied to a selected element to be the same as that of its parent element.
        </p>
        <code>initial</code>
        <p>
            Sets the property value applied to a selected element to the initial value of that property.
        </p>
        <code>revert</code>
        <p>
            Resets the property value applied to a selected element to the browser's default styling 
            rather than the defaults applied to that property. This value acts like unset in many cases.
        </p>
        <code>revert-layer</code>
        <p>
            Resets the property value applied to a selected element to the value established in a 
            previous cascade layer.
        </p>
        <code>unset</code>
        <p>
            Resets the property to its natural value, which means that if the property is naturally 
            inherited it acts like inherit, otherwise it acts like initial.
        </p>
        <h3>Playing with inheritance control properties </h3>
        <ul>
            <li>Default <a href="#">link</a> color</li>
            <li class="my-class-1">Inherit the <a href="#">link</a> color</li>
            <li class="my-class-2">Reset the <a href="#">link</a> color</li>
            <li class="my-class-3">Unset the <a href="#">link</a> color</li>
        </ul>
        <h3>Resetting all property values</h3>
        <p>
            The CSS shorthand property <code>all</code> can be used to apply one of these inheritance 
            values to (almost) all properties at once. Its value can be any one of the inheritance 
            values (<code>inherit</code>, <code>initial</code>, <code>revert</code>, 
            <code>revert-layer</code>, or <code>unset</code> ). 
        </p>
        <blockquote>
            <p>This blockquote is styled</p>
        </blockquote>
        <blockquote class="fix-this">
            <p>This blockquote is not styled</p>
        </blockquote>
        <h2>Understanding the cascade</h2>
        <p>
            There are three factors to consider, listed here in increasing order of importance. Later ones 
            overrule earlier ones:
        </p>
        <ol>
            <li><strong>Source order</strong></li>
            <li><strong>Specificity</strong></li>
            <li><strong>Importance</strong></li>
        </ol>
        <h3>Source order</h3>
        <p>
            If you have more than one rule, all of which have exactly the same weight, then the one that 
            comes last in the CSS will win. You can think of this as: the rule that is nearer the element 
            itself overwrites the earlier ones until the last one wins and gets to style the element.
        </p>
        <h3>Specificity</h3>
        <p>
            Specificity is the algorithm CSS uses to decide which rule wins when multiple selectors affect 
            the same element. It's crucial because it determines which styles are actually applied.
        </p>
        <p>
            Essentially a value in points is awarded to different types of selectors, and adding these 
            up gives you the weight of that particular selector, which can then be assessed against 
            ther potential matches.
        </p>
        <ul>
            <li>
                <p>
                    <strong>IDs</strong>: Score one in this column (100 points) for each ID selector 
                    contained inside the overall selector.
                </p>
            </li>
            <li>
                <p>
                    <strong>Classes</strong>: Score one in this column (10 points) for each class 
                    selector, attribute selector, or pseudo-class contained inside the overall selector.
                </p>
            </li>
            <li>
                <p>
                    <strong>Elements</strong>: Score one in this column (1 point) for each element 
                    selector or pseudo-element contained inside the overall selector.
                </p>
            </li>
        </ul>
        <h4>In-depth specificity example</h4>
        <div class="container" id="outer">
            <div class="container" id="inner">
                <ul>
                    <li class="nav"><a href="#">One</a></li>
                    <li class="nav"><a href="#">Two</a></li>
                </ul>
            </div>
        </div>
        <h3>Inline styles</h3>
        <p>
            Inline styles, that is, the style declaration inside a <code>style</code> attribute, take 
            precedence over all normal styles, no matter the specificity. Such declarations don't have 
            electors, but their specificity can be construed as 1-0-0-0; always more than any other 
            specificity weight no matter how many IDs are in the selectors.
        </p>
        <h3>!Important</h3>
        <p>
            There is a special piece of CSS that you can use to overrule all of the above calculations, even 
            inline styles - the <code>!important</code> flag. However, you should be very careful when using 
            it. This flag is used to make an individual property and value pair the most specific 
            rule, thereby overriding the normal rules of the cascade, including normal inline styles.
        </p>
        <p>
            One situation in which you may have to use the !important flag is when you are working on a 
            CMS where you can't edit the core CSS modules, and you really want to override an inline 
            style or an important declaration that can't be overridden in any other way. But 
            really, don't use it if you can avoid it.
        </p>
        <h2>The effect of CSS location</h2>
        <h3>Order of overriding declarations</h3>
        <p>
            Conflicting declarations will be applied in the following order, with later ones overriding 
            earlier ones:
        </p>
        <ol>
            <li>
                <p>Declarations in user agent style sheets.</p>
            </li>
            <li>
                <p>Normal declarations in user style sheets.</p>
            </li>
            <li>
                <p>Normal declarations in author style sheets.</p>
            </li>
            <li>
                <p>Important declarations in author style sheets.</p>
            </li>
            <li>
                <p>Important declarations in user style sheets.</p>
            </li>
            <li>
                <p>Important declarations in user agent style sheets.</p>
            </li>
        </ol>
        <p>
            Extracted from:
            <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Handling_conflicts" target="_blank">MDN Handling conflicts</a>
        </p>
    </body>
</html>